@page "/upload"
@using SecureFileStorage.Core.Interfaces
@using Microsoft.AspNetCore.Components.Authorization
@using System.IdentityModel.Tokens.Jwt
@using System.Security.Cryptography
@using System.Text
@inject IFileStorageService FileStorageService
@inject IDbContext DbContext
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime

<div class="container mt-4">
    <h3>Prenesi datoteku</h3>

    <InputFile OnChange="@LoadFiles" class="form-control mb-3"/>

    @if (isLoading) {
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Učitavanje...</span>
        </div>
    }

    @if (!string.IsNullOrEmpty(message)) {
        <div class="alert @(isError ? "alert-danger" : "alert-success") mt-3" role="alert">
            @message
        </div>
    }
</div>

@code {
    private bool isLoading;
    private string message;
    private bool isError;

    private async Task LoadFiles(InputFileChangeEventArgs e) {
        try {
            isLoading = true;
            isError = false;
            message = string.Empty;

            var file = e.File;
            using var originalStream = file.OpenReadStream();
            using var memoryStream = new MemoryStream();
            await originalStream.CopyToAsync(memoryStream);
            memoryStream.Position = 0;

            var userId = await GetLoggedInUserIdAsync();
            var uploadTimestamp = DateTime.UtcNow;
            var (signature, publicKeyString) = await GenerateSignatureAsync(file.Name, userId, memoryStream, uploadTimestamp);

            memoryStream.Position = 0;
            var encryptedUrl = await FileStorageService.UploadFileAsync(memoryStream, file.Name, userId);

            var fileEntity = new SecureFileStorage.Core.Entities.File {
                FileName = file.Name,
                EncryptedUrl = encryptedUrl,
                UploaderId = userId,
                UploadedAt = uploadTimestamp,
                Signature = signature,
                PublicKey = publicKeyString
            };

            DbContext.File.Add(fileEntity);
            await DbContext.SaveChangesAsync();

            message = "Datoteka uspješno prenesena!";
        } catch (Exception ex) {
            isError = true;
            message = $"Greška prilikom prijenosa datoteke: {ex.Message}";
        } finally {
            isLoading = false;
        }
    }

    private async Task<int> GetLoggedInUserIdAsync() {
        var token = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "authToken");

        if (string.IsNullOrEmpty(token)) {
            throw new InvalidOperationException("Token not found.");
        }

        var userId = GetUserIdFromToken(token);

        if (userId == null) {
            throw new InvalidOperationException("User ID claim not found in token.");
        }

        return int.Parse(userId);
    }

    private string? GetUserIdFromToken(string token) {
        var handler = new JwtSecurityTokenHandler();
        var jwtToken = handler.ReadJwtToken(token);

        var userIdClaim = jwtToken.Claims.FirstOrDefault(claim => claim.Type == "id");

        return userIdClaim?.Value;
    }

    private async Task<(string Signature, string PublicKey)> GenerateSignatureAsync(string fileName, int userId, Stream fileStream, DateTime uploadTimestamp) {
        using var rsa = new RSACryptoServiceProvider(2048);
        try {
            var privateKey = rsa.ExportParameters(true);
            var publicKey = rsa.ExportParameters(false);

            var publicKeyString = Convert.ToBase64String(rsa.ExportRSAPublicKey());

            using var sha256 = SHA256.Create();
            var fileHash = await ComputeHashAsync(fileStream, sha256);
            var fileHashString = Convert.ToBase64String(fileHash);

            var dataToSign = Encoding.UTF8.GetBytes($"{fileName}{userId}{fileHashString}{uploadTimestamp:O}");
            var signedData = rsa.SignData(dataToSign, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

            var signature = Convert.ToBase64String(signedData);
            return (signature, publicKeyString);
        } finally {
            rsa.PersistKeyInCsp = false;
        }
    }

    private async Task<byte[]> ComputeHashAsync(Stream stream, HashAlgorithm hashAlgorithm) {
        var buffer = new byte[8192];
        int bytesRead;
        while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0) {
            hashAlgorithm.TransformBlock(buffer, 0, bytesRead, null, 0);
        }
        hashAlgorithm.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
        return hashAlgorithm.Hash;
    }
}